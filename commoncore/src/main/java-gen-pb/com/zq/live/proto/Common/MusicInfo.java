// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: Common.proto
package com.zq.live.proto.Common;

import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import okio.ByteString;

/**
 * 音乐信息
 */
public final class MusicInfo extends Message<MusicInfo, MusicInfo.Builder> {
  public static final ProtoAdapter<MusicInfo> ADAPTER = new ProtoAdapter_MusicInfo();

  private static final long serialVersionUID = 0L;

  public static final Integer DEFAULT_ITEMID = 0;

  public static final String DEFAULT_ITEMNAME = "";

  public static final String DEFAULT_COVER = "";

  public static final String DEFAULT_OWNER = "";

  public static final String DEFAULT_LYRIC = "";

  public static final String DEFAULT_ORI = "";

  public static final String DEFAULT_ACC = "";

  public static final String DEFAULT_MIDI = "";

  public static final String DEFAULT_ZIP = "";

  public static final String DEFAULT_RANKBGM = "";

  public static final Integer DEFAULT_BEGINMS = 0;

  public static final Integer DEFAULT_ENDMS = 0;

  public static final String DEFAULT_STANDINTRO = "";

  public static final Integer DEFAULT_STANDINTROBEGINT = 0;

  public static final Integer DEFAULT_STANDINTROENDT = 0;

  public static final Integer DEFAULT_TOTALMS = 0;

  public static final Integer DEFAULT_RANKLRCBEGINT = 0;

  public static final Integer DEFAULT_STANDLRCBEGINT = 0;

  public static final Integer DEFAULT_STANDLRCENDT = 0;

  public static final Boolean DEFAULT_ISBLANK = false;

  public static final String DEFAULT_STANDLRC = "";

  public static final String DEFAULT_RANKUSERVOICE = "";

  public static final Integer DEFAULT_RANKLRCENDT = 0;

  public static final Integer DEFAULT_TASK = 0;

  public static final Integer DEFAULT_STANDTOTALMS = 0;

  public static final Boolean DEFAULT_CHALLENGEAVAILABLE = false;

  /**
   * 音乐条目标识
   */
  @WireField(
      tag = 1,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer itemID;

  /**
   * 音乐条目名称
   */
  @WireField(
      tag = 2,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String itemName;

  /**
   * 音乐条目封页图片
   */
  @WireField(
      tag = 3,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String cover;

  /**
   * 音乐条目所属（歌手）
   */
  @WireField(
      tag = 4,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String owner;

  /**
   * 音乐条目对应歌词
   */
  @WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String lyric;

  /**
   * 原唱:origin
   */
  @WireField(
      tag = 6,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String ori;

  /**
   * 伴奏:accompany
   */
  @WireField(
      tag = 7,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String acc;

  /**
   * 音乐条目对应midi文件
   */
  @WireField(
      tag = 8,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String midi;

  /**
   * 资源压缩文件
   */
  @WireField(
      tag = 9,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String zip;

  /**
   * 匹配玩法的伴奏
   */
  @WireField(
      tag = 10,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String rankBgm;

  /**
   * beginTimeMs,匹配玩法的伴奏开始毫秒
   */
  @WireField(
      tag = 11,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer beginMs;

  /**
   * endTimeMs,匹配玩法的伴奏结束毫秒
   */
  @WireField(
      tag = 12,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer endMs;

  /**
   * standIntro,一唱到底的导唱
   */
  @WireField(
      tag = 13,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String standIntro;

  /**
   * standIntroBeginT,一唱到底导唱的开始毫秒
   */
  @WireField(
      tag = 14,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer standIntroBeginT;

  /**
   * standIntroEndT,一唱到底导唱的结束毫秒
   */
  @WireField(
      tag = 15,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer standIntroEndT;

  /**
   * totalTimeMs,匹配玩法伴奏总时长
   */
  @WireField(
      tag = 16,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer totalMs;

  /**
   * rankLrcBeginT,匹配玩法第一句歌词开始时间,毫秒
   */
  @WireField(
      tag = 17,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer rankLrcBeginT;

  /**
   * standLrcBeginT,一唱到底第一句歌词的开始毫秒
   */
  @WireField(
      tag = 18,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer standLrcBeginT;

  /**
   * standLrcEndT,一唱到底歌词的结束毫秒
   */
  @WireField(
      tag = 19,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer standLrcEndT;

  /**
   * isBlank,是否一唱到底的白板item
   */
  @WireField(
      tag = 20,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL"
  )
  private final Boolean isBlank;

  /**
   * standLrc,一唱到底歌词URL
   */
  @WireField(
      tag = 21,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String standLrc;

  /**
   * rankUserVoice,匹配进入游戏前的背景音乐
   */
  @WireField(
      tag = 22,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  private final String rankUserVoice;

  /**
   * rankLrcEndT,匹配玩法最后一句歌词的结束时间,毫秒
   */
  @WireField(
      tag = 23,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer rankLrcEndT;

  /**
   * 任务等级，若为0，表示非任务歌曲
   */
  @WireField(
      tag = 24,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer task;

  /**
   * 一唱到底伴奏模式的时长
   */
  @WireField(
      tag = 25,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  private final Integer standTotalMs;

  /**
   * 是否支持挑战模式
   */
  @WireField(
      tag = 26,
      adapter = "com.squareup.wire.ProtoAdapter#BOOL"
  )
  private final Boolean challengeAvailable;

  public MusicInfo(Integer itemID, String itemName, String cover, String owner, String lyric,
      String ori, String acc, String midi, String zip, String rankBgm, Integer beginMs,
      Integer endMs, String standIntro, Integer standIntroBeginT, Integer standIntroEndT,
      Integer totalMs, Integer rankLrcBeginT, Integer standLrcBeginT, Integer standLrcEndT,
      Boolean isBlank, String standLrc, String rankUserVoice, Integer rankLrcEndT, Integer task,
      Integer standTotalMs, Boolean challengeAvailable) {
    this(itemID, itemName, cover, owner, lyric, ori, acc, midi, zip, rankBgm, beginMs, endMs, standIntro, standIntroBeginT, standIntroEndT, totalMs, rankLrcBeginT, standLrcBeginT, standLrcEndT, isBlank, standLrc, rankUserVoice, rankLrcEndT, task, standTotalMs, challengeAvailable, ByteString.EMPTY);
  }

  public MusicInfo(Integer itemID, String itemName, String cover, String owner, String lyric,
      String ori, String acc, String midi, String zip, String rankBgm, Integer beginMs,
      Integer endMs, String standIntro, Integer standIntroBeginT, Integer standIntroEndT,
      Integer totalMs, Integer rankLrcBeginT, Integer standLrcBeginT, Integer standLrcEndT,
      Boolean isBlank, String standLrc, String rankUserVoice, Integer rankLrcEndT, Integer task,
      Integer standTotalMs, Boolean challengeAvailable, ByteString unknownFields) {
    super(ADAPTER, unknownFields);
    this.itemID = itemID;
    this.itemName = itemName;
    this.cover = cover;
    this.owner = owner;
    this.lyric = lyric;
    this.ori = ori;
    this.acc = acc;
    this.midi = midi;
    this.zip = zip;
    this.rankBgm = rankBgm;
    this.beginMs = beginMs;
    this.endMs = endMs;
    this.standIntro = standIntro;
    this.standIntroBeginT = standIntroBeginT;
    this.standIntroEndT = standIntroEndT;
    this.totalMs = totalMs;
    this.rankLrcBeginT = rankLrcBeginT;
    this.standLrcBeginT = standLrcBeginT;
    this.standLrcEndT = standLrcEndT;
    this.isBlank = isBlank;
    this.standLrc = standLrc;
    this.rankUserVoice = rankUserVoice;
    this.rankLrcEndT = rankLrcEndT;
    this.task = task;
    this.standTotalMs = standTotalMs;
    this.challengeAvailable = challengeAvailable;
  }

  @Override
  public Builder newBuilder() {
    Builder builder = new Builder();
    builder.itemID = itemID;
    builder.itemName = itemName;
    builder.cover = cover;
    builder.owner = owner;
    builder.lyric = lyric;
    builder.ori = ori;
    builder.acc = acc;
    builder.midi = midi;
    builder.zip = zip;
    builder.rankBgm = rankBgm;
    builder.beginMs = beginMs;
    builder.endMs = endMs;
    builder.standIntro = standIntro;
    builder.standIntroBeginT = standIntroBeginT;
    builder.standIntroEndT = standIntroEndT;
    builder.totalMs = totalMs;
    builder.rankLrcBeginT = rankLrcBeginT;
    builder.standLrcBeginT = standLrcBeginT;
    builder.standLrcEndT = standLrcEndT;
    builder.isBlank = isBlank;
    builder.standLrc = standLrc;
    builder.rankUserVoice = rankUserVoice;
    builder.rankLrcEndT = rankLrcEndT;
    builder.task = task;
    builder.standTotalMs = standTotalMs;
    builder.challengeAvailable = challengeAvailable;
    builder.addUnknownFields(unknownFields());
    return builder;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof MusicInfo)) return false;
    MusicInfo o = (MusicInfo) other;
    return unknownFields().equals(o.unknownFields())
        && Internal.equals(itemID, o.itemID)
        && Internal.equals(itemName, o.itemName)
        && Internal.equals(cover, o.cover)
        && Internal.equals(owner, o.owner)
        && Internal.equals(lyric, o.lyric)
        && Internal.equals(ori, o.ori)
        && Internal.equals(acc, o.acc)
        && Internal.equals(midi, o.midi)
        && Internal.equals(zip, o.zip)
        && Internal.equals(rankBgm, o.rankBgm)
        && Internal.equals(beginMs, o.beginMs)
        && Internal.equals(endMs, o.endMs)
        && Internal.equals(standIntro, o.standIntro)
        && Internal.equals(standIntroBeginT, o.standIntroBeginT)
        && Internal.equals(standIntroEndT, o.standIntroEndT)
        && Internal.equals(totalMs, o.totalMs)
        && Internal.equals(rankLrcBeginT, o.rankLrcBeginT)
        && Internal.equals(standLrcBeginT, o.standLrcBeginT)
        && Internal.equals(standLrcEndT, o.standLrcEndT)
        && Internal.equals(isBlank, o.isBlank)
        && Internal.equals(standLrc, o.standLrc)
        && Internal.equals(rankUserVoice, o.rankUserVoice)
        && Internal.equals(rankLrcEndT, o.rankLrcEndT)
        && Internal.equals(task, o.task)
        && Internal.equals(standTotalMs, o.standTotalMs)
        && Internal.equals(challengeAvailable, o.challengeAvailable);
  }

  @Override
  public int hashCode() {
    int result = super.hashCode;
    if (result == 0) {
      result = unknownFields().hashCode();
      result = result * 37 + (itemID != null ? itemID.hashCode() : 0);
      result = result * 37 + (itemName != null ? itemName.hashCode() : 0);
      result = result * 37 + (cover != null ? cover.hashCode() : 0);
      result = result * 37 + (owner != null ? owner.hashCode() : 0);
      result = result * 37 + (lyric != null ? lyric.hashCode() : 0);
      result = result * 37 + (ori != null ? ori.hashCode() : 0);
      result = result * 37 + (acc != null ? acc.hashCode() : 0);
      result = result * 37 + (midi != null ? midi.hashCode() : 0);
      result = result * 37 + (zip != null ? zip.hashCode() : 0);
      result = result * 37 + (rankBgm != null ? rankBgm.hashCode() : 0);
      result = result * 37 + (beginMs != null ? beginMs.hashCode() : 0);
      result = result * 37 + (endMs != null ? endMs.hashCode() : 0);
      result = result * 37 + (standIntro != null ? standIntro.hashCode() : 0);
      result = result * 37 + (standIntroBeginT != null ? standIntroBeginT.hashCode() : 0);
      result = result * 37 + (standIntroEndT != null ? standIntroEndT.hashCode() : 0);
      result = result * 37 + (totalMs != null ? totalMs.hashCode() : 0);
      result = result * 37 + (rankLrcBeginT != null ? rankLrcBeginT.hashCode() : 0);
      result = result * 37 + (standLrcBeginT != null ? standLrcBeginT.hashCode() : 0);
      result = result * 37 + (standLrcEndT != null ? standLrcEndT.hashCode() : 0);
      result = result * 37 + (isBlank != null ? isBlank.hashCode() : 0);
      result = result * 37 + (standLrc != null ? standLrc.hashCode() : 0);
      result = result * 37 + (rankUserVoice != null ? rankUserVoice.hashCode() : 0);
      result = result * 37 + (rankLrcEndT != null ? rankLrcEndT.hashCode() : 0);
      result = result * 37 + (task != null ? task.hashCode() : 0);
      result = result * 37 + (standTotalMs != null ? standTotalMs.hashCode() : 0);
      result = result * 37 + (challengeAvailable != null ? challengeAvailable.hashCode() : 0);
      super.hashCode = result;
    }
    return result;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    if (itemID != null) builder.append(", itemID=").append(itemID);
    if (itemName != null) builder.append(", itemName=").append(itemName);
    if (cover != null) builder.append(", cover=").append(cover);
    if (owner != null) builder.append(", owner=").append(owner);
    if (lyric != null) builder.append(", lyric=").append(lyric);
    if (ori != null) builder.append(", ori=").append(ori);
    if (acc != null) builder.append(", acc=").append(acc);
    if (midi != null) builder.append(", midi=").append(midi);
    if (zip != null) builder.append(", zip=").append(zip);
    if (rankBgm != null) builder.append(", rankBgm=").append(rankBgm);
    if (beginMs != null) builder.append(", beginMs=").append(beginMs);
    if (endMs != null) builder.append(", endMs=").append(endMs);
    if (standIntro != null) builder.append(", standIntro=").append(standIntro);
    if (standIntroBeginT != null) builder.append(", standIntroBeginT=").append(standIntroBeginT);
    if (standIntroEndT != null) builder.append(", standIntroEndT=").append(standIntroEndT);
    if (totalMs != null) builder.append(", totalMs=").append(totalMs);
    if (rankLrcBeginT != null) builder.append(", rankLrcBeginT=").append(rankLrcBeginT);
    if (standLrcBeginT != null) builder.append(", standLrcBeginT=").append(standLrcBeginT);
    if (standLrcEndT != null) builder.append(", standLrcEndT=").append(standLrcEndT);
    if (isBlank != null) builder.append(", isBlank=").append(isBlank);
    if (standLrc != null) builder.append(", standLrc=").append(standLrc);
    if (rankUserVoice != null) builder.append(", rankUserVoice=").append(rankUserVoice);
    if (rankLrcEndT != null) builder.append(", rankLrcEndT=").append(rankLrcEndT);
    if (task != null) builder.append(", task=").append(task);
    if (standTotalMs != null) builder.append(", standTotalMs=").append(standTotalMs);
    if (challengeAvailable != null) builder.append(", challengeAvailable=").append(challengeAvailable);
    return builder.replace(0, 2, "MusicInfo{").append('}').toString();
  }

  public byte[] toByteArray() {
    return MusicInfo.ADAPTER.encode(this);
  }

  public static final MusicInfo parseFrom(byte[] data) throws IOException {
    MusicInfo c = null;
       c = MusicInfo.ADAPTER.decode(data);
    return c;
  }

  /**
   * 音乐条目标识
   */
  public Integer getItemID() {
    if(itemID==null){
        return DEFAULT_ITEMID;
    }
    return itemID;
  }

  /**
   * 音乐条目名称
   */
  public String getItemName() {
    if(itemName==null){
        return DEFAULT_ITEMNAME;
    }
    return itemName;
  }

  /**
   * 音乐条目封页图片
   */
  public String getCover() {
    if(cover==null){
        return DEFAULT_COVER;
    }
    return cover;
  }

  /**
   * 音乐条目所属（歌手）
   */
  public String getOwner() {
    if(owner==null){
        return DEFAULT_OWNER;
    }
    return owner;
  }

  /**
   * 音乐条目对应歌词
   */
  public String getLyric() {
    if(lyric==null){
        return DEFAULT_LYRIC;
    }
    return lyric;
  }

  /**
   * 原唱:origin
   */
  public String getOri() {
    if(ori==null){
        return DEFAULT_ORI;
    }
    return ori;
  }

  /**
   * 伴奏:accompany
   */
  public String getAcc() {
    if(acc==null){
        return DEFAULT_ACC;
    }
    return acc;
  }

  /**
   * 音乐条目对应midi文件
   */
  public String getMidi() {
    if(midi==null){
        return DEFAULT_MIDI;
    }
    return midi;
  }

  /**
   * 资源压缩文件
   */
  public String getZip() {
    if(zip==null){
        return DEFAULT_ZIP;
    }
    return zip;
  }

  /**
   * 匹配玩法的伴奏
   */
  public String getRankBgm() {
    if(rankBgm==null){
        return DEFAULT_RANKBGM;
    }
    return rankBgm;
  }

  /**
   * beginTimeMs,匹配玩法的伴奏开始毫秒
   */
  public Integer getBeginMs() {
    if(beginMs==null){
        return DEFAULT_BEGINMS;
    }
    return beginMs;
  }

  /**
   * endTimeMs,匹配玩法的伴奏结束毫秒
   */
  public Integer getEndMs() {
    if(endMs==null){
        return DEFAULT_ENDMS;
    }
    return endMs;
  }

  /**
   * standIntro,一唱到底的导唱
   */
  public String getStandIntro() {
    if(standIntro==null){
        return DEFAULT_STANDINTRO;
    }
    return standIntro;
  }

  /**
   * standIntroBeginT,一唱到底导唱的开始毫秒
   */
  public Integer getStandIntroBeginT() {
    if(standIntroBeginT==null){
        return DEFAULT_STANDINTROBEGINT;
    }
    return standIntroBeginT;
  }

  /**
   * standIntroEndT,一唱到底导唱的结束毫秒
   */
  public Integer getStandIntroEndT() {
    if(standIntroEndT==null){
        return DEFAULT_STANDINTROENDT;
    }
    return standIntroEndT;
  }

  /**
   * totalTimeMs,匹配玩法伴奏总时长
   */
  public Integer getTotalMs() {
    if(totalMs==null){
        return DEFAULT_TOTALMS;
    }
    return totalMs;
  }

  /**
   * rankLrcBeginT,匹配玩法第一句歌词开始时间,毫秒
   */
  public Integer getRankLrcBeginT() {
    if(rankLrcBeginT==null){
        return DEFAULT_RANKLRCBEGINT;
    }
    return rankLrcBeginT;
  }

  /**
   * standLrcBeginT,一唱到底第一句歌词的开始毫秒
   */
  public Integer getStandLrcBeginT() {
    if(standLrcBeginT==null){
        return DEFAULT_STANDLRCBEGINT;
    }
    return standLrcBeginT;
  }

  /**
   * standLrcEndT,一唱到底歌词的结束毫秒
   */
  public Integer getStandLrcEndT() {
    if(standLrcEndT==null){
        return DEFAULT_STANDLRCENDT;
    }
    return standLrcEndT;
  }

  /**
   * isBlank,是否一唱到底的白板item
   */
  public Boolean getIsBlank() {
    if(isBlank==null){
        return DEFAULT_ISBLANK;
    }
    return isBlank;
  }

  /**
   * standLrc,一唱到底歌词URL
   */
  public String getStandLrc() {
    if(standLrc==null){
        return DEFAULT_STANDLRC;
    }
    return standLrc;
  }

  /**
   * rankUserVoice,匹配进入游戏前的背景音乐
   */
  public String getRankUserVoice() {
    if(rankUserVoice==null){
        return DEFAULT_RANKUSERVOICE;
    }
    return rankUserVoice;
  }

  /**
   * rankLrcEndT,匹配玩法最后一句歌词的结束时间,毫秒
   */
  public Integer getRankLrcEndT() {
    if(rankLrcEndT==null){
        return DEFAULT_RANKLRCENDT;
    }
    return rankLrcEndT;
  }

  /**
   * 任务等级，若为0，表示非任务歌曲
   */
  public Integer getTask() {
    if(task==null){
        return DEFAULT_TASK;
    }
    return task;
  }

  /**
   * 一唱到底伴奏模式的时长
   */
  public Integer getStandTotalMs() {
    if(standTotalMs==null){
        return DEFAULT_STANDTOTALMS;
    }
    return standTotalMs;
  }

  /**
   * 是否支持挑战模式
   */
  public Boolean getChallengeAvailable() {
    if(challengeAvailable==null){
        return DEFAULT_CHALLENGEAVAILABLE;
    }
    return challengeAvailable;
  }

  /**
   * 音乐条目标识
   */
  public boolean hasItemID() {
    return itemID!=null;
  }

  /**
   * 音乐条目名称
   */
  public boolean hasItemName() {
    return itemName!=null;
  }

  /**
   * 音乐条目封页图片
   */
  public boolean hasCover() {
    return cover!=null;
  }

  /**
   * 音乐条目所属（歌手）
   */
  public boolean hasOwner() {
    return owner!=null;
  }

  /**
   * 音乐条目对应歌词
   */
  public boolean hasLyric() {
    return lyric!=null;
  }

  /**
   * 原唱:origin
   */
  public boolean hasOri() {
    return ori!=null;
  }

  /**
   * 伴奏:accompany
   */
  public boolean hasAcc() {
    return acc!=null;
  }

  /**
   * 音乐条目对应midi文件
   */
  public boolean hasMidi() {
    return midi!=null;
  }

  /**
   * 资源压缩文件
   */
  public boolean hasZip() {
    return zip!=null;
  }

  /**
   * 匹配玩法的伴奏
   */
  public boolean hasRankBgm() {
    return rankBgm!=null;
  }

  /**
   * beginTimeMs,匹配玩法的伴奏开始毫秒
   */
  public boolean hasBeginMs() {
    return beginMs!=null;
  }

  /**
   * endTimeMs,匹配玩法的伴奏结束毫秒
   */
  public boolean hasEndMs() {
    return endMs!=null;
  }

  /**
   * standIntro,一唱到底的导唱
   */
  public boolean hasStandIntro() {
    return standIntro!=null;
  }

  /**
   * standIntroBeginT,一唱到底导唱的开始毫秒
   */
  public boolean hasStandIntroBeginT() {
    return standIntroBeginT!=null;
  }

  /**
   * standIntroEndT,一唱到底导唱的结束毫秒
   */
  public boolean hasStandIntroEndT() {
    return standIntroEndT!=null;
  }

  /**
   * totalTimeMs,匹配玩法伴奏总时长
   */
  public boolean hasTotalMs() {
    return totalMs!=null;
  }

  /**
   * rankLrcBeginT,匹配玩法第一句歌词开始时间,毫秒
   */
  public boolean hasRankLrcBeginT() {
    return rankLrcBeginT!=null;
  }

  /**
   * standLrcBeginT,一唱到底第一句歌词的开始毫秒
   */
  public boolean hasStandLrcBeginT() {
    return standLrcBeginT!=null;
  }

  /**
   * standLrcEndT,一唱到底歌词的结束毫秒
   */
  public boolean hasStandLrcEndT() {
    return standLrcEndT!=null;
  }

  /**
   * isBlank,是否一唱到底的白板item
   */
  public boolean hasIsBlank() {
    return isBlank!=null;
  }

  /**
   * standLrc,一唱到底歌词URL
   */
  public boolean hasStandLrc() {
    return standLrc!=null;
  }

  /**
   * rankUserVoice,匹配进入游戏前的背景音乐
   */
  public boolean hasRankUserVoice() {
    return rankUserVoice!=null;
  }

  /**
   * rankLrcEndT,匹配玩法最后一句歌词的结束时间,毫秒
   */
  public boolean hasRankLrcEndT() {
    return rankLrcEndT!=null;
  }

  /**
   * 任务等级，若为0，表示非任务歌曲
   */
  public boolean hasTask() {
    return task!=null;
  }

  /**
   * 一唱到底伴奏模式的时长
   */
  public boolean hasStandTotalMs() {
    return standTotalMs!=null;
  }

  /**
   * 是否支持挑战模式
   */
  public boolean hasChallengeAvailable() {
    return challengeAvailable!=null;
  }

  public static final class Builder extends Message.Builder<MusicInfo, Builder> {
    private Integer itemID;

    private String itemName;

    private String cover;

    private String owner;

    private String lyric;

    private String ori;

    private String acc;

    private String midi;

    private String zip;

    private String rankBgm;

    private Integer beginMs;

    private Integer endMs;

    private String standIntro;

    private Integer standIntroBeginT;

    private Integer standIntroEndT;

    private Integer totalMs;

    private Integer rankLrcBeginT;

    private Integer standLrcBeginT;

    private Integer standLrcEndT;

    private Boolean isBlank;

    private String standLrc;

    private String rankUserVoice;

    private Integer rankLrcEndT;

    private Integer task;

    private Integer standTotalMs;

    private Boolean challengeAvailable;

    public Builder() {
    }

    /**
     * 音乐条目标识
     */
    public Builder setItemID(Integer itemID) {
      this.itemID = itemID;
      return this;
    }

    /**
     * 音乐条目名称
     */
    public Builder setItemName(String itemName) {
      this.itemName = itemName;
      return this;
    }

    /**
     * 音乐条目封页图片
     */
    public Builder setCover(String cover) {
      this.cover = cover;
      return this;
    }

    /**
     * 音乐条目所属（歌手）
     */
    public Builder setOwner(String owner) {
      this.owner = owner;
      return this;
    }

    /**
     * 音乐条目对应歌词
     */
    public Builder setLyric(String lyric) {
      this.lyric = lyric;
      return this;
    }

    /**
     * 原唱:origin
     */
    public Builder setOri(String ori) {
      this.ori = ori;
      return this;
    }

    /**
     * 伴奏:accompany
     */
    public Builder setAcc(String acc) {
      this.acc = acc;
      return this;
    }

    /**
     * 音乐条目对应midi文件
     */
    public Builder setMidi(String midi) {
      this.midi = midi;
      return this;
    }

    /**
     * 资源压缩文件
     */
    public Builder setZip(String zip) {
      this.zip = zip;
      return this;
    }

    /**
     * 匹配玩法的伴奏
     */
    public Builder setRankBgm(String rankBgm) {
      this.rankBgm = rankBgm;
      return this;
    }

    /**
     * beginTimeMs,匹配玩法的伴奏开始毫秒
     */
    public Builder setBeginMs(Integer beginMs) {
      this.beginMs = beginMs;
      return this;
    }

    /**
     * endTimeMs,匹配玩法的伴奏结束毫秒
     */
    public Builder setEndMs(Integer endMs) {
      this.endMs = endMs;
      return this;
    }

    /**
     * standIntro,一唱到底的导唱
     */
    public Builder setStandIntro(String standIntro) {
      this.standIntro = standIntro;
      return this;
    }

    /**
     * standIntroBeginT,一唱到底导唱的开始毫秒
     */
    public Builder setStandIntroBeginT(Integer standIntroBeginT) {
      this.standIntroBeginT = standIntroBeginT;
      return this;
    }

    /**
     * standIntroEndT,一唱到底导唱的结束毫秒
     */
    public Builder setStandIntroEndT(Integer standIntroEndT) {
      this.standIntroEndT = standIntroEndT;
      return this;
    }

    /**
     * totalTimeMs,匹配玩法伴奏总时长
     */
    public Builder setTotalMs(Integer totalMs) {
      this.totalMs = totalMs;
      return this;
    }

    /**
     * rankLrcBeginT,匹配玩法第一句歌词开始时间,毫秒
     */
    public Builder setRankLrcBeginT(Integer rankLrcBeginT) {
      this.rankLrcBeginT = rankLrcBeginT;
      return this;
    }

    /**
     * standLrcBeginT,一唱到底第一句歌词的开始毫秒
     */
    public Builder setStandLrcBeginT(Integer standLrcBeginT) {
      this.standLrcBeginT = standLrcBeginT;
      return this;
    }

    /**
     * standLrcEndT,一唱到底歌词的结束毫秒
     */
    public Builder setStandLrcEndT(Integer standLrcEndT) {
      this.standLrcEndT = standLrcEndT;
      return this;
    }

    /**
     * isBlank,是否一唱到底的白板item
     */
    public Builder setIsBlank(Boolean isBlank) {
      this.isBlank = isBlank;
      return this;
    }

    /**
     * standLrc,一唱到底歌词URL
     */
    public Builder setStandLrc(String standLrc) {
      this.standLrc = standLrc;
      return this;
    }

    /**
     * rankUserVoice,匹配进入游戏前的背景音乐
     */
    public Builder setRankUserVoice(String rankUserVoice) {
      this.rankUserVoice = rankUserVoice;
      return this;
    }

    /**
     * rankLrcEndT,匹配玩法最后一句歌词的结束时间,毫秒
     */
    public Builder setRankLrcEndT(Integer rankLrcEndT) {
      this.rankLrcEndT = rankLrcEndT;
      return this;
    }

    /**
     * 任务等级，若为0，表示非任务歌曲
     */
    public Builder setTask(Integer task) {
      this.task = task;
      return this;
    }

    /**
     * 一唱到底伴奏模式的时长
     */
    public Builder setStandTotalMs(Integer standTotalMs) {
      this.standTotalMs = standTotalMs;
      return this;
    }

    /**
     * 是否支持挑战模式
     */
    public Builder setChallengeAvailable(Boolean challengeAvailable) {
      this.challengeAvailable = challengeAvailable;
      return this;
    }

    @Override
    public MusicInfo build() {
      return new MusicInfo(itemID, itemName, cover, owner, lyric, ori, acc, midi, zip, rankBgm, beginMs, endMs, standIntro, standIntroBeginT, standIntroEndT, totalMs, rankLrcBeginT, standLrcBeginT, standLrcEndT, isBlank, standLrc, rankUserVoice, rankLrcEndT, task, standTotalMs, challengeAvailable, super.buildUnknownFields());
    }
  }

  private static final class ProtoAdapter_MusicInfo extends ProtoAdapter<MusicInfo> {
    public ProtoAdapter_MusicInfo() {
      super(FieldEncoding.LENGTH_DELIMITED, MusicInfo.class);
    }

    @Override
    public int encodedSize(MusicInfo value) {
      return ProtoAdapter.UINT32.encodedSizeWithTag(1, value.itemID)
          + ProtoAdapter.STRING.encodedSizeWithTag(2, value.itemName)
          + ProtoAdapter.STRING.encodedSizeWithTag(3, value.cover)
          + ProtoAdapter.STRING.encodedSizeWithTag(4, value.owner)
          + ProtoAdapter.STRING.encodedSizeWithTag(5, value.lyric)
          + ProtoAdapter.STRING.encodedSizeWithTag(6, value.ori)
          + ProtoAdapter.STRING.encodedSizeWithTag(7, value.acc)
          + ProtoAdapter.STRING.encodedSizeWithTag(8, value.midi)
          + ProtoAdapter.STRING.encodedSizeWithTag(9, value.zip)
          + ProtoAdapter.STRING.encodedSizeWithTag(10, value.rankBgm)
          + ProtoAdapter.UINT32.encodedSizeWithTag(11, value.beginMs)
          + ProtoAdapter.UINT32.encodedSizeWithTag(12, value.endMs)
          + ProtoAdapter.STRING.encodedSizeWithTag(13, value.standIntro)
          + ProtoAdapter.UINT32.encodedSizeWithTag(14, value.standIntroBeginT)
          + ProtoAdapter.UINT32.encodedSizeWithTag(15, value.standIntroEndT)
          + ProtoAdapter.UINT32.encodedSizeWithTag(16, value.totalMs)
          + ProtoAdapter.UINT32.encodedSizeWithTag(17, value.rankLrcBeginT)
          + ProtoAdapter.UINT32.encodedSizeWithTag(18, value.standLrcBeginT)
          + ProtoAdapter.UINT32.encodedSizeWithTag(19, value.standLrcEndT)
          + ProtoAdapter.BOOL.encodedSizeWithTag(20, value.isBlank)
          + ProtoAdapter.STRING.encodedSizeWithTag(21, value.standLrc)
          + ProtoAdapter.STRING.encodedSizeWithTag(22, value.rankUserVoice)
          + ProtoAdapter.UINT32.encodedSizeWithTag(23, value.rankLrcEndT)
          + ProtoAdapter.UINT32.encodedSizeWithTag(24, value.task)
          + ProtoAdapter.UINT32.encodedSizeWithTag(25, value.standTotalMs)
          + ProtoAdapter.BOOL.encodedSizeWithTag(26, value.challengeAvailable)
          + value.unknownFields().size();
    }

    @Override
    public void encode(ProtoWriter writer, MusicInfo value) throws IOException {
      ProtoAdapter.UINT32.encodeWithTag(writer, 1, value.itemID);
      ProtoAdapter.STRING.encodeWithTag(writer, 2, value.itemName);
      ProtoAdapter.STRING.encodeWithTag(writer, 3, value.cover);
      ProtoAdapter.STRING.encodeWithTag(writer, 4, value.owner);
      ProtoAdapter.STRING.encodeWithTag(writer, 5, value.lyric);
      ProtoAdapter.STRING.encodeWithTag(writer, 6, value.ori);
      ProtoAdapter.STRING.encodeWithTag(writer, 7, value.acc);
      ProtoAdapter.STRING.encodeWithTag(writer, 8, value.midi);
      ProtoAdapter.STRING.encodeWithTag(writer, 9, value.zip);
      ProtoAdapter.STRING.encodeWithTag(writer, 10, value.rankBgm);
      ProtoAdapter.UINT32.encodeWithTag(writer, 11, value.beginMs);
      ProtoAdapter.UINT32.encodeWithTag(writer, 12, value.endMs);
      ProtoAdapter.STRING.encodeWithTag(writer, 13, value.standIntro);
      ProtoAdapter.UINT32.encodeWithTag(writer, 14, value.standIntroBeginT);
      ProtoAdapter.UINT32.encodeWithTag(writer, 15, value.standIntroEndT);
      ProtoAdapter.UINT32.encodeWithTag(writer, 16, value.totalMs);
      ProtoAdapter.UINT32.encodeWithTag(writer, 17, value.rankLrcBeginT);
      ProtoAdapter.UINT32.encodeWithTag(writer, 18, value.standLrcBeginT);
      ProtoAdapter.UINT32.encodeWithTag(writer, 19, value.standLrcEndT);
      ProtoAdapter.BOOL.encodeWithTag(writer, 20, value.isBlank);
      ProtoAdapter.STRING.encodeWithTag(writer, 21, value.standLrc);
      ProtoAdapter.STRING.encodeWithTag(writer, 22, value.rankUserVoice);
      ProtoAdapter.UINT32.encodeWithTag(writer, 23, value.rankLrcEndT);
      ProtoAdapter.UINT32.encodeWithTag(writer, 24, value.task);
      ProtoAdapter.UINT32.encodeWithTag(writer, 25, value.standTotalMs);
      ProtoAdapter.BOOL.encodeWithTag(writer, 26, value.challengeAvailable);
      writer.writeBytes(value.unknownFields());
    }

    @Override
    public MusicInfo decode(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      long token = reader.beginMessage();
      for (int tag; (tag = reader.nextTag()) != -1;) {
        switch (tag) {
          case 1: builder.setItemID(ProtoAdapter.UINT32.decode(reader)); break;
          case 2: builder.setItemName(ProtoAdapter.STRING.decode(reader)); break;
          case 3: builder.setCover(ProtoAdapter.STRING.decode(reader)); break;
          case 4: builder.setOwner(ProtoAdapter.STRING.decode(reader)); break;
          case 5: builder.setLyric(ProtoAdapter.STRING.decode(reader)); break;
          case 6: builder.setOri(ProtoAdapter.STRING.decode(reader)); break;
          case 7: builder.setAcc(ProtoAdapter.STRING.decode(reader)); break;
          case 8: builder.setMidi(ProtoAdapter.STRING.decode(reader)); break;
          case 9: builder.setZip(ProtoAdapter.STRING.decode(reader)); break;
          case 10: builder.setRankBgm(ProtoAdapter.STRING.decode(reader)); break;
          case 11: builder.setBeginMs(ProtoAdapter.UINT32.decode(reader)); break;
          case 12: builder.setEndMs(ProtoAdapter.UINT32.decode(reader)); break;
          case 13: builder.setStandIntro(ProtoAdapter.STRING.decode(reader)); break;
          case 14: builder.setStandIntroBeginT(ProtoAdapter.UINT32.decode(reader)); break;
          case 15: builder.setStandIntroEndT(ProtoAdapter.UINT32.decode(reader)); break;
          case 16: builder.setTotalMs(ProtoAdapter.UINT32.decode(reader)); break;
          case 17: builder.setRankLrcBeginT(ProtoAdapter.UINT32.decode(reader)); break;
          case 18: builder.setStandLrcBeginT(ProtoAdapter.UINT32.decode(reader)); break;
          case 19: builder.setStandLrcEndT(ProtoAdapter.UINT32.decode(reader)); break;
          case 20: builder.setIsBlank(ProtoAdapter.BOOL.decode(reader)); break;
          case 21: builder.setStandLrc(ProtoAdapter.STRING.decode(reader)); break;
          case 22: builder.setRankUserVoice(ProtoAdapter.STRING.decode(reader)); break;
          case 23: builder.setRankLrcEndT(ProtoAdapter.UINT32.decode(reader)); break;
          case 24: builder.setTask(ProtoAdapter.UINT32.decode(reader)); break;
          case 25: builder.setStandTotalMs(ProtoAdapter.UINT32.decode(reader)); break;
          case 26: builder.setChallengeAvailable(ProtoAdapter.BOOL.decode(reader)); break;
          default: {
            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
            builder.addUnknownField(tag, fieldEncoding, value);
          }
        }
      }
      reader.endMessage(token);
      return builder.build();
    }

    @Override
    public MusicInfo redact(MusicInfo value) {
      Builder builder = value.newBuilder();
      builder.clearUnknownFields();
      return builder.build();
    }
  }
}
